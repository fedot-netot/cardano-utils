#!/bin/bash

trap exit1 TERM
trap exit1_ INT
trap signalLog USR1

JORMUNGANDR_START_CMD=${JORMUNGANDR_START_CMD:-"systemctl start jormungandr.service"}
JORMUNGANDR_STOP_CMD=${JORMUNGANDR_STOP_CMD:-"systemctl stop jormungandr.service"}
JORMUNGANDR_RESTART_CMD=${JORMUNGANDR_RESTART_CMD:-"systemctl restart jormungandr.service"}

DEFAULT_CHECK_INTERVAL=10 # 10 seconds
DEFAULT_CRITICAL_LAG_IN_SEC=100 # 100 seconds
DEFAULT_UNBELIVABLE_TIME_WO_BLOCKS_IN_NET=200 # 200 seconds
DEFAULT_REPORT_INTERVAL=60*60 # 1 hour
DEFAULT_CRITICAL_BOOTSTRAP_DURATION=10*60 # 10 minutes

START_TIME=$(date +%s)
LAST_REPORT_PERIOD_START=$START_TIME
UPTIME=0
DOWNTIME=0
REPORT_PERIOD_UPTIME=0
REPORT_PERIOD_DOWNTIME=0
CHECK_CYCLES_FROM_START=0
TOTAL_BOOTSTRAP_DURATION=0
TOTAL_BOOTSTRAP_COUNT=0
TOTAL_UPTIME_DURATION=0
TOTAL_UPTIME_COUNT=0
LAST_BOOTSTRAP_DURATION=0
JUST_RESTARTED=0
LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT=0
LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_DURATION=0
LAST_REPORT_PERIOD_TOTAL_UPTIME_DURATION=0
LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT=0
TOTAL_CONNECTIONS=0
MAX_CONNECTIONS=0
TOTAL_CONNECTIONS_COUNT=0
LAST_REPORT_PERIOD_TOTAL_CONNECTIONS=0
LAST_REPORT_PERIOD_MAX_CONNECTIONS=0
LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT=0

TOTAL_LAG_COUNT=0
TOTAL_LAG=0
MAX_LAG=0
LAST_REPORT_PERIOD_TOTAL_LAG_COUNT=0
LAST_REPORT_PERIOD_TOTAL_LAG=0
LAST_REPORT_PERIOD_MAX_LAG=0


function is_number {
  if [[ "$1" =~ ^[[:digit:]]+$ ]]; then
    return 0
  else
    return 1
  fi
}

function printInterval {
  local T=$1
  local always_show_seconds=${2:-"yes"}
  local D=$((T/60/60/24))
  local H=$((T/60/60%24))
  local M=$((T/60%60))
  local S=$((T%60))
  (( $D == 1 )) && printf '%d day ' $D
  (( $D >  1 )) && printf '%d days ' $D
  (( $H == 1 )) && printf '%d hour ' $H
  (( $H >  1 )) && printf '%d hours ' $H
  (( $M == 1 )) && printf '%d minute ' $M
  (( $M >  1 )) && printf '%d minutes ' $M
  if [ "$always_show_seconds" == "yes" ] || (( $S > 0 )); then
      (( $D > 0 || $H > 0 || $M > 0 )) && printf 'and '
      (( $S == 1 )) && printf '%d second' $S
      (( $S != 1 )) && printf '%d seconds' $S
  fi
}

function printInterval2 {
  local T=$1
  local D=$((T/60/60/24))
  local H=$((T/60/60%24))
  local M=$((T/60%60))
  local S=$((T%60))
  (( $D > 0 )) && printf '%dd ' $D
  (( $H > 0 )) && printf '%dh ' $H
  (( $M > 0 )) && printf '%dm ' $M
  (( $S > 0 )) && printf '%ds' $S
}

function parseInterval {
    local interval=$(cat)
    local result
    if is_number $interval; then
        (( result = interval ))
    elif is_number ${interval: : -1}; then
        local value=${interval: : -1}
        local unit=${interval: $(( ${#interval} -1 ))  : 1}
        case $unit in
            s) (( result = value ));;
            m) (( result = value * 60 ));;
            h) (( result = value * 60 * 60 ));;
            d) (( result = value * 60 * 60 * 24 ));;
            w) (( result = value * 60 * 60 * 24 * 7 ));;
            *) exit 1;;
        esac
    fi
    if [ -n "$result" ]; then
        printf "%d" $result
    else
        return 1
    fi
}

WITH_JOURNALD=0
LOG_LEVEL=3 # 1 - error, 2 - warn, 3 - info, 4 - debug, 5 - trace
CRITICAL_LAG_IN_SEC=$DEFAULT_CRITICAL_LAG_IN_SEC
CHECK_INTERVAL=$DEFAULT_CHECK_INTERVAL
UNBELIVABLE_TIME_WO_BLOCKS_IN_NET=$DEFAULT_UNBELIVABLE_TIME_WO_BLOCKS_IN_NET
REPORT_INTERVAL=$DEFAULT_REPORT_INTERVAL
CRITICAL_BOOTSTRAP_DURATION=$DEFAULT_CRITICAL_BOOTSTRAP_DURATION
T_CHANNEL_ID=$TELEGRAM_CHANNEL_ID
T_AUTH_TOKEN=$TELEGRAM_BOT_AUTH_TOKEN
T_MESSAGE_HEADER=


function showHelp {
    cat <<EOF
usage: $(basename $0) [-i INTERVAL] [-l INTERVAL] [-w INTERVAL] [-b INTERVAL] [-r INTERVAL] [-L LOG_LEVEL] [-j] [-h]
  -i  The frequency in at which jormungandr health checks will occure.
      If not specified then $(printInterval $DEFAULT_CHECK_INTERVAL no) interval will be used.
  -l  Critical lag. If not defined then default value of $(printInterval $DEFAULT_CRITICAL_LAG_IN_SEC no) will be used.
  -w  Time interval without blocks in the net that can apear. If our node does not receive blocks during
      this interval then it will be restarted.
      Default value - $(printInterval $DEFAULT_UNBELIVABLE_TIME_WO_BLOCKS_IN_NET no).
  -b  Maximum bootstrap duration after wich the node will be restarted again.
      Default value is $(printInterval $DEFAULT_CRITICAL_BOOTSTRAP_DURATION no).
  -r  Report inteval. If not specified then default value of $(printInterval $DEFAULT_REPORT_INTERVAL no)
      will be used.
  -j  Prepare messages for journald severity levels.
  -L  Log level: 1 - error; 2 - warn; 3 - info; 4 - debug; 5 - trace
  -a  Bot access token. If not specified then environment variable with name \`TELEGRAM_BOT_AUTH_TOKEN\`
      will be used for authentication. If none specified then telegram output will not be used.
  -c  Telegram channel to which publish statistics. E.g. \`@CardanoNodesHeartbeat\`. If not specified then
      the environment variable \`TELEGRAM_BOT_AUTH_TOKEN\` will be used.
  -p  Telegram messages header. If defined it will be the first line of every message.
  -h  Show this help.

This scrip observes jormungandr healh. And if jormungandr is not running and syncing then start/restart it.

By default, it is assumed that all time INTERVALs are set in seconds. But you can explicitly specify time units:
`s` - seconds, `m` - minutes, `h` - hours, `d` - days, `w` - weeks. E.g. `25s`, `15m`, `1h`.
EOF
}


function logError {
    if (( LOG_LEVEL >= 1  )); then
        if [ "$SIMPLE_LOGGING" == "yes" ]; then
            echo "$1"
        else
            (( WITH_JOURNALD )) && echo -n '<3>'
            echo -e "\e[31m$1\e[0m" >&2
        fi
    fi
}

function logWarn {
    if (( LOG_LEVEL >= 2  )); then
        if [ "$SIMPLE_LOGGING" == "yes" ]; then
            echo "$1"
        else
            (( WITH_JOURNALD )) && echo -n '<4>'
            echo -e "\e[93m$1\e[0m" >&2
        fi
    fi
}

function logNotice {
    if (( LOG_LEVEL >= 3  )); then
        if [ "$SIMPLE_LOGGING" == "yes" ]; then
            echo "$1"
        else
            (( WITH_JOURNALD )) && echo -n '<5>'
            echo -e "\e[1m$1\e[0m"
        fi
    fi
}

function logInfo {
    if (( LOG_LEVEL >= 3  )); then
        if [ "$SIMPLE_LOGGING" == "yes" ]; then
            echo "$1"
        else
            (( WITH_JOURNALD )) && echo -n '<6>'
            echo -e "$1"
        fi
    fi
}

function logDebug {
    if (( LOG_LEVEL >= 5  )); then
        if [ "$SIMPLE_LOGGING" == "yes" ]; then
            echo "$1"
        else
            (( WITH_JOURNALD )) && echo -n '<7>'
            echo -e "\e[2m$1\e[0m"
        fi
    fi
}

function logTrace {
    logDebug $1
}



while getopts 'i:l:L:w:b:r:a:c:p:jh' c
do
    case $c in
        i) CHECK_INTERVAL=$(printf "%s" $OPTARG | parseInterval)
           if [ -z $CHECK_INTERVAL ] || (( CHECK_INTERVAL <= 0 )); then
               echo 'Wrong value for option `-i`'
               showHelp;
               exit 1
           fi
           ;;
        l) CRITICAL_LAG_IN_SEC=$(printf "%s" $OPTARG | parseInterval)
           if [ -z $CRITICAL_LAG_IN_SEC ] || (( CRITICAL_LAG_IN_SEC < 0 )); then
               echo 'Wrong value for option `-l`'
               showHelp;
               exit 1
           fi
           ;;
        w) UNBELIVABLE_TIME_WO_BLOCKS_IN_NET=$(printf "%s" $OPTARG | parseInterval)
           if [ -z $UNBELIVABLE_TIME_WO_BLOCKS_IN_NET ] || (( UNBELIVABLE_TIME_WO_BLOCKS_IN_NET < 0 )); then
               echo 'Wrong value for option `-w`'
               showHelp;
               exit 1
           fi
           ;;
        b) CRITICAL_BOOTSTRAP_DURATION=$(printf "%s" $OPTARG | parseInterval)
           if [ -z $CRITICAL_BOOTSTRAP_DURATION ] || (( CRITICAL_BOOTSTRAP_DURATION < 0 )); then
               echo 'Wrong value for option `-b`'
               showHelp;
               exit 1
           fi
           ;;
        r) REPORT_INTERVAL=$(printf "%s" $OPTARG | parseInterval)
           if [ -z $REPORT_INTERVAL ] || (( REPORT_INTERVAL < 0 )); then
               echo 'Wrong value for option `-r`'
               showHelp;
               exit 1
           fi
           ;;
        L) case "$OPTARG" in
               error) LOG_LEVEL=1;;
               warn) LOG_LEVEL=2;;
               info) LOG_LEVEL=3;;
               debug) LOG_LEVEL=4;;
               trace) LOG_LEVEL=5;;
               *) echo 'Wrong value for option `-L`'; showHelp; exit 1;;
           esac;;
        j) WITH_JOURNALD=1;;
        a) T_AUTH_TOKEN="$OPTARG" ;;
        c) T_CHANNEL_ID="$OPTARG" ;;
        p) T_MESSAGE_HEADER="$OPTARG" ;;
        h) showHelp; exit 0 ;;
    esac
done


NOW=$(date +%s)

PREV_state=
PREV_CHECK_DATE=

state=
lastBlockTime=
lastReceivedBlockTime=
uptime=
CHECK_DATE=$NOW
CONNECTIONS=


function isCriticalLag {
    local LAST_TIME PREV_TIME LAG MAX_LAG
    LAST_TIME=$1
    PREV_TIME=$2
    MAX_LAG=${3:-$CRITICAL_LAG_IN_SEC}
    if !(is_number $LAST_TIME && is_number $PREV_TIME); then
        logError "Not numeric arguments!!!"
        return 1
    fi
    LAG=$(( LAST_TIME - PREV_TIME ))
    logDebug "LAG=$LAG"
    return $(( LAG < MAX_LAG ))
}

function incrementUptime {
    (( UPTIME += CHECK_INTERVAL ))
    (( REPORT_PERIOD_UPTIME += CHECK_INTERVAL ))
}

function incrementDowntime {
    (( DOWNTIME += CHECK_INTERVAL ))
    (( REPORT_PERIOD_DOWNTIME += CHECK_INTERVAL ))
}

function incrementBootstrapDuration {
    (( LAST_BOOTSTRAP_DURATION += CHECK_INTERVAL ))
    (( TOTAL_BOOTSTRAP_DURATION += CHECK_INTERVAL ))
    (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_DURATION += CHECK_INTERVAL ))
}

function incrementUptimeDuration {
    (( TOTAL_UPTIME_COUNT++ ))
    (( LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT++ ))
    (( LAST_UPTIME_DURATION += uptime ))
    (( TOTAL_UPTIME_DURATION += uptime ))
    (( LAST_REPORT_PERIOD_TOTAL_UPTIME_DURATION += uptime ))
}

function incrementConnectionStatistic {
    if is_number "$CONNECTIONS"; then
        (( TOTAL_CONNECTIONS_COUNT += 1 ))
        (( TOTAL_CONNECTIONS += CONNECTIONS ))
        (( CONNECTIONS > MAX_CONNECTIONS )) && (( MAX_CONNECTIONS = CONNECTIONS ))
        (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT += 1 ))
        (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS += CONNECTIONS ))
        (( CONNECTIONS > LAST_REPORT_PERIOD_MAX_CONNECTIONS )) && (( LAST_REPORT_PERIOD_MAX_CONNECTIONS = CONNECTIONS ))
    fi
}

function incrementLagStatistic {
    if is_number "$lastBlockTime" && is_number "$lastReceivedBlockTime" && (( lastReceivedBlockTime >= lastBlockTime )); then
        local LAG
        (( LAG = lastReceivedBlockTime - lastBlockTime ))
        (( TOTAL_LAG_COUNT += 1 ))
        (( TOTAL_LAG += LAG ))
        (( LAG > MAX_LAG )) && (( MAX_LAG = LAG ))
        (( LAST_REPORT_PERIOD_TOTAL_LAG_COUNT += 1 ))
        (( LAST_REPORT_PERIOD_TOTAL_LAG += LAG ))
        (( LAG > LAST_REPORT_PERIOD_MAX_LAG )) && (( LAST_REPORT_PERIOD_MAX_LAG = LAG ))
    fi
}

function stopJormungandr {
    eval "$JORMUNGANDR_STOP_CMD"
}

function startJormungandr {
    eval "$JORMUNGANDR_START_CMD"
}

function restartJormungandr {
    eval "$JORMUNGANDR_RESTART_CMD"
    LAST_BOOTSTRAP_START=$CHECK_DATE
}

function isBootstrappingState {
    if [ "$1" == "Bootstrapping" ] || [ "$1" == "PreparingBlock0" ]; then
        return 0
    else
        return 1
    fi
}

function isRunningState {
    if [ "$1" == "Running" ]; then
        return 0
    else
        return 1
    fi
}

function readJormungandrState {
    local JSON ERR_MSG
    unset state lastBlockTime lastReceivedBlockTime uptime

    eval "$( (jcli rest v0 node stats get --output-format=json) 2> >(ERR_MSG=$(cat); declare -p ERR_MSG) > >(JSON=$(cat); declare -p JSON) )"

    if [ -n "$ERR_MSG" ]; then logError "$ERR_MSG"; fi
    state=$(echo -n $JSON | jq -r .state)
    if isRunningState $state; then
        lastBlockTime=$(date +%s -d$( echo -n "$JSON" | jq -r .lastBlockTime 2>/dev/null) 2>/dev/null)
        lastReceivedBlockTime=$(date +%s -d$( echo -n "$JSON" | jq -r .lastReceivedBlockTime 2>/dev/null) 2>/dev/null)
        uptime=$(echo -n "$JSON" | jq -r .uptime 2>/dev/null)
    fi
    CONNECTIONS=$(netstat -tnp 2>/dev/null| grep -E 'ESTABLISHED.+jormungandr' | cut -c45-65 | sort | uniq | wc -l)
    CHECK_DATE=$(date +%s)
}

function sendToTelegram {
    local INPUT=$(cat)
    if [ -n "$T_AUTH_TOKEN" ] && [ -n "$T_CHANNEL_ID" ]; then
        echo -e "${T_MESSAGE_HEADER:+${T_MESSAGE_HEADER}\n\n}${INPUT}" | \
        curl --silent \
             --request POST https://api.telegram.org/bot$T_AUTH_TOKEN/sendMessage \
             --data parse_mode=HTML \
             --data chat_id="$T_CHANNEL_ID" \
             --data-urlencode text@- \
             > /dev/null
    fi
}

function logTotal()
(
    local SIMPLE_LOGGING=$1
    if (( UPTIME == 0 && DOWNTIME == 0 )); then
        return
    fi

    function log {
        if [ "$SIMPLE_LOGGING" == "yes" ]; then
            logNotice "===== <b>Total statistics</b> ====="
            logNotice "Time elapsed: <u><b><i>$(printInterval2 $(( now - START_TIME )))</i></b></u>"
            logNotice "Node was running: <u><b><i>${uptime_percent}%</i></b></u> of time"
            if (( TOTAL_UPTIME_COUNT > 1 )); then
            logNotice "Avr. uptime duration: <u><b><i>$(printInterval2 $(( TOTAL_UPTIME_DURATION / TOTAL_UPTIME_COUNT )))</i></b></u>"
            elif [ -n "$uptime" ] && (( uptime > 0 )); then
            logNotice "Single uptime duration: <u><b><i>$(printInterval2 $(( uptime )))</i></b></u>"
            fi
            logNotice "Node was bootstrapped: <u><b><i>$TOTAL_BOOTSTRAP_COUNT</i></b></u> time(s)"
            if (( TOTAL_BOOTSTRAP_COUNT > 0 )); then
            logNotice "Avr. bootstrap duration: <u><b><i>$(printInterval2 $(( TOTAL_BOOTSTRAP_DURATION / TOTAL_BOOTSTRAP_COUNT )))</i></b></u>"
            fi
            if (( TOTAL_CONNECTIONS_COUNT > 1 )); then
            logNotice "Avr/Max neighbors count: <u><b><i>$(( TOTAL_CONNECTIONS / TOTAL_CONNECTIONS_COUNT ))</i></b></u>/<u><b><i>$(( MAX_CONNECTIONS ))</i></b></u>"
            fi
            if (( TOTAL_LAG_COUNT > 0 )); then
            logNotice "Avr/Max lag in seconds: <u><b><i>$(( TOTAL_LAG / TOTAL_LAG_COUNT ))</i></b></u>/<u><b><i>$MAX_LAG</i></b></u>"
            fi
        else
            logNotice "Total statistics since overseer started:"
            logNotice "  time elapsed:                $(printInterval $(( now - START_TIME )))"
            logNotice "  node was running:            ${uptime_percent}% of time"
            if (( TOTAL_UPTIME_COUNT > 1 )); then
            logNotice "  average uptime duration:     $(printInterval $(( TOTAL_UPTIME_DURATION / TOTAL_UPTIME_COUNT )))"
            elif [ -n "$uptime" ] && (( uptime > 0 )); then
            logNotice "  single uptime duration:      $(printInterval $(( uptime )))"
            fi
            logNotice "  node was bootstrapped:       $TOTAL_BOOTSTRAP_COUNT time(s)"
            if (( TOTAL_BOOTSTRAP_COUNT > 0 )); then
            logNotice "  average bootstrap duration:  $(printInterval $(( TOTAL_BOOTSTRAP_DURATION / TOTAL_BOOTSTRAP_COUNT )))"
            fi
            if (( TOTAL_CONNECTIONS_COUNT > 1 )); then
            logNotice "  average/max neighbors count: $(( TOTAL_CONNECTIONS / TOTAL_CONNECTIONS_COUNT )) / $MAX_CONNECTIONS"
            fi
            if (( TOTAL_LAG_COUNT > 0 )); then
            logNotice "  average/max lag in seconds:  $(( TOTAL_LAG / TOTAL_LAG_COUNT )) / $MAX_LAG"
            fi
        fi
    }

    local uptime_percent
    if (( DOWNTIME > 0 )); then
        uptime_percent=$(echo "scale=2; ${UPTIME:-0}*100/(${UPTIME:-0} + ${DOWNTIME}) " | bc -l)
    elif (( UPTIME > 0 )); then
        uptime_percent="100.00"
    else
        uptime_percent="0"
    fi
    local now=$(date +%s)

    log
)

function logLastPeriod()
(
    local SIMPLE_LOGGING=$1

    if (( UPTIME == 0 && DOWNTIME == 0 )); then
        return
    fi

    function log {
        if [ "$SIMPLE_LOGGING" == "yes" ]; then
            logNotice "===== <b>Last $(printInterval2 $(( REPORT_INTERVAL ))) statistic</b> ====="

            logNotice "Node was running: <u><b><i>${uptime_percent}%</i></b></u> of time"
            if (( LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT > 1 )); then
            logNotice "Avr. uptime duration: <u><b><i>$(printInterval2 $(( LAST_REPORT_PERIOD_TOTAL_UPTIME_DURATION / LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT )))</i></b></u>"
            elif [ -n "$uptime" ] && (( uptime > 0 )); then
            logNotice "Single uptime duration: <u><b><i>$(printInterval2 $(( uptime )))</i></b></u>"
            fi
            logNotice "Node was bootstrapped: <u><b><i>${LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT}</i></b></u> time(s)"
            if (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT > 0 )); then
            logNotice "Avr. bootstrap duration: <u><b><i>$(printInterval2 $(( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_DURATION / LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT )))</i></b></u>"
            fi
            if (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT > 1 )); then
            logNotice "Avr/Max neighbors count: <u><b><i>$(( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS / LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT ))</i></b></u>/<u><b><i></i></b>$LAST_REPORT_PERIOD_MAX_CONNECTIONS</u>"
            fi
            if (( LAST_REPORT_PERIOD_TOTAL_LAG_COUNT > 0 )); then
            logNotice "Avr/Max lag in seconds: <u><b><i>$(( LAST_REPORT_PERIOD_TOTAL_LAG / LAST_REPORT_PERIOD_TOTAL_LAG_COUNT ))</i></b></u>/<u><b><i>$LAST_REPORT_PERIOD_MAX_LAG</i></b></u>"
            fi
        else
            logNotice "Statistics for the last $(printInterval $REPORT_INTERVAL no):"
            logNotice "  node was running:            ${uptime_percent}% of time"
            if (( LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT > 1 )); then
            logNotice "  average uptime duration:     $(printInterval $(( LAST_REPORT_PERIOD_TOTAL_UPTIME_DURATION / LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT )))"
            elif [ -n "$uptime" ] && (( uptime > 0 )); then
            logNotice "  single uptime duration:      $(printInterval $(( uptime )))"
            fi
            logNotice "  node was bootstrapped:       $LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT time(s)"
            if (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT > 0 )); then
            logNotice "  average bootstrap duration:  $(printInterval $(( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_DURATION / LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT )))"
            fi
            if (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT > 1 )); then
            logNotice "  average/max neighbors count: $(( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS / LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT )) / $LAST_REPORT_PERIOD_MAX_CONNECTIONS"
            fi
            if (( LAST_REPORT_PERIOD_TOTAL_LAG_COUNT > 0 )); then
            logNotice "  average/max lag in seconds:  $(( LAST_REPORT_PERIOD_TOTAL_LAG / LAST_REPORT_PERIOD_TOTAL_LAG_COUNT )) / $LAST_REPORT_PERIOD_MAX_LAG"
            fi
        fi
    }
    local uptime_percent
    if (( REPORT_PERIOD_DOWNTIME > 0 )); then
        uptime_percent=$(echo "scale=2; ${REPORT_PERIOD_UPTIME:-0}*100/(${REPORT_PERIOD_UPTIME:-0} + ${REPORT_PERIOD_DOWNTIME}) " | bc -l)
    elif (( UPTIME > 0 )); then
        uptime_percent="100.00"
    else
        uptime_percent="0"
    fi
    local now=$(date +%s)

    log
)

function startNewPeriod {
    (( LAST_REPORT_PERIOD_START = CHECK_DATE ))
    (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_DURATION = 0 ))
    (( REPORT_PERIOD_UPTIME = 0 ))
    (( REPORT_PERIOD_DOWNTIME = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_UPTIME_DURATION = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS = 0 ))
    (( LAST_REPORT_PERIOD_MAX_CONNECTIONS = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_LAG_COUNT = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_LAG = 0 ))
    (( LAST_REPORT_PERIOD_MAX_LAG = 0 ))
}

function exit1 {
    logTotal 'no'
    exit 1
}

function exit1_ {
    echo
    exit1
}

function signalLog {
    logTotal 'no'
    logTotal 'yes' | sendToTelegram
}

while :;
do
    just_restarted=$JUST_RESTARTED
    (( JUST_RESTARTED = 0 ))
    readJormungandrState
    logTrace "state                 : $state"
    logTrace "lastBlockTime         : $lastBlockTime"
    logTrace "lastReceivedBlockTime : $lastReceivedBlockTime"
    logTrace "now                   : $CHECK_DATE"
    logTrace "uptime                : $uptime"
    logTrace "CONNECTIONS           : $CONNECTIONS"

    if (( (CHECK_DATE - LAST_REPORT_PERIOD_START) >= REPORT_INTERVAL )); then
        logTotal
        logLastPeriod
        echo -e "$(logTotal yes)\n\n$(logLastPeriod yes)" | sendToTelegram
        startNewPeriod
    fi

    if [ -z "$state" ]; then
        if [ -z "$PREV_CHECK_DATE" ]; then
            if is_number "$CONNECTIONS"; then
                logError "Jormungandr is started but not responding or something wrong with our script"
            else
                logWarn "Starting jormungandr because it looking stopped."
                stopJormungandr
                startJormungandr
            fi;
        elif isCriticalLag $CHECK_DATE $PREV_CHECK_DATE; then
            logWarn "Starting jormungandr because it not responding last $(printInterval $CRITICAL_LAG_IN_SEC no)."
            stopJormungandr
            startJormungandr
        fi
    elif isBootstrappingState $state; then
        if ! isBootstrappingState $PREV_state; then
            if (( just_restarted )); then
                logInfo "Bootstrapping..."
            else
                logNotice "Bootstrapping..."
            fi
            (( TOTAL_BOOTSTRAP_COUNT++ ))
            (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT++ ))
        fi
        if isCriticalLag ${LAST_BOOTSTRAP_START:-$CHECK_DATE} $CHECK_DATE $CRITICAL_BOOTSTRAP_DURATION; then
            logWarn "Restarting node because of bootstrap process took more than $(printInterval $CRITICAL_BOOTSTRAP_DURATION)"
            if restartJormungandr; then
                (( JUST_RESTARTED = 1 ))
            fi
        fi
        incrementBootstrapDuration
        incrementDowntime
    elif isRunningState $state; then
        unset LAST_BOOTSTRAP_START
        incrementConnectionStatistic
        incrementLagStatistic
        if isBootstrappingState $PREV_state; then
            incrementBootstrapDuration
            logNotice "Node bootstrapped in $LAST_BOOTSTRAP_DURATION seconds ($(printInterval $LAST_BOOTSTRAP_DURATION))"
        elif ! isRunningState $PREV_state; then
            logNotice "Node is running"
        else
            if isCriticalLag $uptime 0 && isCriticalLag ${lastReceivedBlockTime:-$CHECK_DATE} $lastBlockTime; then
                logWarn "Restarting node because of some blocks did not received during $(printInterval $CRITICAL_LAG_IN_SEC no)"
                logInfo "Uptime before restart: $uptime seconds ($(printInterval $uptime))"
                incrementDowntime
                incrementUptimeDuration
                if restartJormungandr; then
                    (( JUST_RESTARTED = 1 ))
                fi
            elif isCriticalLag $CHECK_DATE ${lastReceivedBlockTime:-$CHECK_DATE} $UNBELIVABLE_TIME_WO_BLOCKS_IN_NET; then
                logWarn "Restarting node because no one block has been received during last $(printInterval $UNBELIVABLE_TIME_WO_BLOCKS_IN_NET no)"
                logInfo "Uptime before restart: $uptime seconds ($(printInterval $uptime))"
                incrementDowntime
                incrementUptimeDuration
                if restartJormungandr; then
                    (( JUST_RESTARTED = 1 ))
                fi
            else
                incrementUptime
            fi
        fi
        (( LAST_BOOTSTRAP_DURATION = 0 ))
    else
        logError "Unknown node state: $state"
    fi

    if isRunningState $state || isBootstrappingState $state; then
        PREV_CHECK_DATE=$CHECK_DATE
    fi
    PREV_state=$state

    sleep "${CHECK_INTERVAL}s"
    (( CHECK_CYCLES_FROM_START += 1 ))
done
