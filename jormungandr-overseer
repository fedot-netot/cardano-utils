#!/bin/bash

trap exit1 TERM
trap exit1_ INT
trap logTotal USR1

JORMUNGANDR_START_CMD=${JORMUNGANDR_START_CMD:-"systemctl start jormungandr.service"}
JORMUNGANDR_STOP_CMD=${JORMUNGANDR_STOP_CMD:-"systemctl stop jormungandr.service"}
JORMUNGANDR_RESTART_CMD=${JORMUNGANDR_RESTART_CMD:-"systemctl restart jormungandr.service"}

DEFAULT_CHECK_INTERVAL=10
DEFAULT_CRITICAL_LAG_IN_SEC=100
DEFAULT_UNBELIVABLE_TIME_WO_BLOCKS_IN_NET=200
DEFAULT_REPORT_INTERVAL=1

START_TIME=$(date +%s)
LAST_REPORT_PERIOD_START=$START_TIME
UPTIME=0
DOWNTIME=0
REPORT_PERIOD_UPTIME=0
REPORT_PERIOD_DOWNTIME=0
CHECK_CYCLES_FROM_START=0
TOTAL_BOOTSTRAP_DURATION=0
TOTAL_BOOTSTRAP_COUNT=0
TOTAL_UPTIME_DURATION=0
TOTAL_UPTIME_COUNT=0
LAST_BOOTSTRAP_DURATION=0
JUST_RESTARTED=0
LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT=0
LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_DURATION=0
LAST_REPORT_PERIOD_TOTAL_UPTIME_DURATION=0
LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT=0
TOTAL_CONNECTIONS=0
TOTAL_CONNECTIONS_COUNT=0
LAST_REPORT_PERIOD_TOTAL_CONNECTIONS=0
LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT=0


WITH_JOURNALD=0
LOG_LEVEL=3 # 1 - error, 2 - warn, 3 - info, 4 - debug, 5 - trace
CRITICAL_LAG_IN_SEC=$DEFAULT_CRITICAL_LAG_IN_SEC
CHECK_INTERVAL=$DEFAULT_CHECK_INTERVAL
UNBELIVABLE_TIME_WO_BLOCKS_IN_NET=$DEFAULT_UNBELIVABLE_TIME_WO_BLOCKS_IN_NET
REPORT_INTERVAL=$DEFAULT_REPORT_INTERVAL

function showHelp {
    cat <<EOF
usage: $(basename $0) [-i INTERVAL] [-l LAG] [-w LAG_WO_BLOCK] [-L LOG_LEVEL] [-r INTERVAL] [-j] [-h]
  -i  The frequency in seconds at which jormungandr health checks will occure.
      If not specified then $DEFAULT_CHECK_INTERVAL seconds interval will be used.
  -l  Critical lag in seconds. If not defined then default value of $DEFAULT_CRITICAL_LAG_IN_SEC will be used.
  -w  Count of seconds without blocks in the net that can apear. If our node does not receive blocks during
      this interval then it will be restarted. Default value - $DEFAULT_UNBELIVABLE_TIME_WO_BLOCKS_IN_NET.
  -L  Log level: 1 - error; 2 - warn; 3 - info; 4 - debug; 5 - trace
  -j  Prepare messages for journald severity levels.
  -r  Report inteval in hours.
  -h  Show this help.

This scrip checks if jormungandr
EOF
}


function is_number {
  if [[ "$1" =~ ^[[:digit:]]+$ ]]; then
    return 0
  else
    return 1
  fi
}

function displaytime {
  local T=$1
  local always_show_seconds=${2:-"yes"}
  local D=$((T/60/60/24))
  local H=$((T/60/60%24))
  local M=$((T/60%60))
  local S=$((T%60))
  (( $D == 1 )) && printf '%d day ' $D
  (( $D >  1 )) && printf '%d days ' $D
  (( $H == 1 )) && printf '%d hour ' $H
  (( $H >  1 )) && printf '%d hours ' $H
  (( $M == 1 )) && printf '%d minute ' $M
  (( $M >  1 )) && printf '%d minutes ' $M
  if [ "$always_show_seconds" == "yes" ] || (( $S > 0 )); then
      (( $D > 0 || $H > 0 || $M > 0 )) && printf 'and '
      (( $S == 1 )) && printf '%d second' $S
      (( $S != 1 )) && printf '%d seconds' $S
  fi
}

function logError {
    if (( LOG_LEVEL >= 1  )); then
        (( WITH_JOURNALD )) && echo -n '<3>'
        echo -e "\e[31m$1\e[0m" >&2
    fi
}

function logWarn {
    if (( LOG_LEVEL >= 2  )); then
        (( WITH_JOURNALD )) && echo -n '<4>'
        echo -e "\e[93m$1\e[0m" >&2
    fi
}

function logNotice {
    if (( LOG_LEVEL >= 3  )); then
        (( WITH_JOURNALD )) && echo -n '<5>'
        echo -e "\e[1m$1\e[0m"
    fi
}

function logInfo {
    if (( LOG_LEVEL >= 3  )); then
        (( WITH_JOURNALD )) && echo -n '<6>'
        echo -e "$1"
    fi
}

function logDebug {
    if (( LOG_LEVEL >= 5  )); then
        (( WITH_JOURNALD )) && echo -n '<7>'
        echo -e "\e[2m$1\e[0m"
    fi
}

function logTrace {
    logDebug $1
}



while getopts 'i:l:L:w:r:jh' c
do
    case $c in
        i) CHECK_INTERVAL="$OPTARG" ;;
        l) if is_number "$OPTARG"; then
               CRITICAL_LAG_IN_SEC=$OPTARG
           else
               echo 'Wrong value for option `-l`'
               showHelp;
               exit 1
           fi;;
        w) if is_number "$OPTARG"; then
               UNBELIVABLE_TIME_WO_BLOCKS_IN_NET=$OPTARG
           else
               echo 'Wrong value for option `-w`'
               showHelp;
               exit 1
           fi;;
        L) case "$OPTARG" in
               error) LOG_LEVEL=1;;
               warn) LOG_LEVEL=2;;
               info) LOG_LEVEL=3;;
               debug) LOG_LEVEL=4;;
               trace) LOG_LEVEL=5;;
               *) echo 'Wrong value for option `-L`'; showHelp; exit 1;;
           esac;;
        j) WITH_JOURNALD=1;;
        r) if is_number "$OPTARG"; then
               REPORT_INTERVAL=$OPTARG
           else
               echo 'Wrong value for option `-r`'
               showHelp;
               exit 1
           fi;;
        h) showHelp; exit 0 ;;
    esac
done



NOW=$(date +%s)

PREV_state=
PREV_CHECK_DATE=

state=
lastBlockTime=
lastReceivedBlockTime=
uptime=
CHECK_DATE=
CONNECTIONS=


function isCriticalLag {
    local LAST_TIME PREV_TIME LAG MAX_LAG
    LAST_TIME=$1
    PREV_TIME=$2
    MAX_LAG=${3:-$CRITICAL_LAG_IN_SEC}
    if !(is_number $LAST_TIME && is_number $PREV_TIME); then
        logError "Not numeric arguments!!!"
        return 1
    fi
    LAG=$(( LAST_TIME - PREV_TIME ))
    logDebug "LAG=$LAG"
    return $(( LAG < MAX_LAG ))
}

function incrementUptime {
    (( UPTIME += CHECK_INTERVAL ))
    (( REPORT_PERIOD_UPTIME += CHECK_INTERVAL ))
}

function incrementDowntime {
    (( DOWNTIME += CHECK_INTERVAL ))
    (( REPORT_PERIOD_DOWNTIME += CHECK_INTERVAL ))
}

function incrementBootstrapDuration {
    (( LAST_BOOTSTRAP_DURATION += CHECK_INTERVAL ))
    (( TOTAL_BOOTSTRAP_DURATION += CHECK_INTERVAL ))
    (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_DURATION += CHECK_INTERVAL ))
}

function incrementUptimeDuration {
    (( TOTAL_UPTIME_COUNT++ ))
    (( LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT++ ))
    (( LAST_UPTIME_DURATION += uptime ))
    (( TOTAL_UPTIME_DURATION += uptime ))
    (( LAST_REPORT_PERIOD_TOTAL_UPTIME_DURATION += uptime ))
}

function incrementConnectionStatistic {
    if is_number "$CONNECTIONS"; then
        (( TOTAL_CONNECTIONS_COUNT += 1 ))
        (( TOTAL_CONNECTIONS += CONNECTIONS ))
        (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT += 1 ))
        (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS += CONNECTIONS ))
    fi
}

function stopJormungandr {
    eval "$JORMUNGANDR_STOP_CMD"
}

function startJormungandr {
    eval "$JORMUNGANDR_START_CMD"
}

function restartJormungandr {
    eval "$JORMUNGANDR_RESTART_CMD"
}

function isBootstrappingState {
    if [ "$1" == "Bootstrapping" ] || [ "$1" == "PreparingBlock0" ]; then
        return 0
    else
        return 1
    fi
}

function isRunningState {
    if [ "$1" == "Running" ]; then
        return 0
    else
        return 1
    fi
}

function readJormungandrState {
    local JSON ERR_MSG
    unset state lastBlockTime lastReceivedBlockTime uptime

    eval "$( (jcli rest v0 node stats get --output-format=json) 2> >(ERR_MSG=$(cat); declare -p ERR_MSG) > >(JSON=$(cat); declare -p JSON) )"

    if [ -n "$ERR_MSG" ]; then logError "$ERR_MSG"; fi
    state=$(echo -n $JSON | jq -r .state)
    if isRunningState $state; then
        lastBlockTime=$(date +%s -d$( echo -n "$JSON" | jq -r .lastBlockTime 2>/dev/null) 2>/dev/null)
        lastReceivedBlockTime=$(date +%s -d$( echo -n "$JSON" | jq -r .lastReceivedBlockTime 2>/dev/null) 2>/dev/null)
        uptime=$(echo -n "$JSON" | jq -r .uptime 2>/dev/null)
    fi
    CONNECTIONS=$(netstat -tnp 2>/dev/null| grep -E 'ESTABLISHED.+jormungandr' | cut -c45-65 | sort | uniq | wc -l)
    CHECK_DATE=$(date +%s)
}

function logTotal {
    if (( UPTIME == 0 && DOWNTIME == 0 )); then
        return
    fi
    local uptime_percent
    if (( DOWNTIME > 0 )); then
        uptime_percent=$(echo "scale=2; ${UPTIME:-0}*100/(${UPTIME:-0} + ${DOWNTIME}) " | bc -l)
    elif (( UPTIME > 0 )); then
        uptime_percent="100.00"
    else
        uptime_percent="0"
    fi

    local now=$(date +%s)
    logNotice "Total statistics since overseer started:"
    logNotice "  time elapsed:               $(displaytime $(( now - START_TIME )))"
    logNotice "  node was running:           ${uptime_percent}% of time"
    if (( TOTAL_UPTIME_COUNT > 1 )); then
    logNotice "  average uptime duration:    $(displaytime $(( TOTAL_UPTIME_DURATION / TOTAL_UPTIME_COUNT )))"
    elif [ -n "$uptime" ] && (( uptime > 0 )); then
    logNotice "  single uptime duration:     $(displaytime $(( uptime )))"
    fi
    logNotice "  node was bootstrapped:      $TOTAL_BOOTSTRAP_COUNT time(s)"
    if (( TOTAL_BOOTSTRAP_COUNT > 0 )); then
    logNotice "  average bootstrap duration: $(displaytime $(( TOTAL_BOOTSTRAP_DURATION / TOTAL_BOOTSTRAP_COUNT )))"
    fi
    if (( TOTAL_CONNECTIONS_COUNT > 1 )); then
    logNotice "  average neighbors count:    $(( TOTAL_CONNECTIONS / TOTAL_CONNECTIONS_COUNT ))"
    fi
}

function logLastPeriod {
    local uptime_percent
    if (( REPORT_PERIOD_DOWNTIME > 0 )); then
        uptime_percent=$(echo "scale=2; ${REPORT_PERIOD_UPTIME:-0}*100/(${REPORT_PERIOD_UPTIME:-0} + ${REPORT_PERIOD_DOWNTIME}) " | bc -l)
    elif (( UPTIME > 0 )); then
        uptime_percent="100.00"
    else
        uptime_percent="0"
    fi

    local now=$(date +%s)
    if (( REPORT_INTERVAL == 1 )); then
        logNotice "Statistics for the last hour:"
    else
        logNotice "Statistics for the last $REPORT_INTERVAL hours:"
    fi
    logNotice "  node was running:           ${uptime_percent}% of time"
    if (( LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT > 1 )); then
    logNotice "  average uptime duration:    $(displaytime $(( LAST_REPORT_PERIOD_TOTAL_UPTIME_DURATION / LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT )))"
    elif [ -n "$uptime" ] && (( uptime > 0 )); then
    logNotice "  single uptime duration:     $(displaytime $(( uptime )))"
    fi
    logNotice "  node was bootstrapped:      $LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT time(s)"
    if (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT > 0 )); then
    logNotice "  average bootstrap duration: $(displaytime $(( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_DURATION / LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT )))"
    fi
    if (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT > 1 )); then
    logNotice "  average neighbors count:    $(( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS / LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT ))"
    fi

    (( LAST_REPORT_PERIOD_START = CHECK_DATE ))
    (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_DURATION = 0 ))
    (( REPORT_PERIOD_UPTIME = 0 ))
    (( REPORT_PERIOD_DOWNTIME = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_UPTIME_COUNT = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_UPTIME_DURATION = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS_COUNT = 0 ))
    (( LAST_REPORT_PERIOD_TOTAL_CONNECTIONS = 0 ))
}

function exit1 {
    logTotal
    exit 1
}

function exit1_ {
    echo
    exit1
}

while :;
do
    just_restarted=$JUST_RESTARTED
    (( JUST_RESTARTED = 0 ))
    readJormungandrState
    logTrace "state                 : $state"
    logTrace "lastBlockTime         : $lastBlockTime"
    logTrace "lastReceivedBlockTime : $lastReceivedBlockTime"
    logTrace "now                   : $CHECK_DATE"
    logTrace "uptime                : $uptime"
    logTrace "CONNECTIONS           : $CONNECTIONS"

    if (( (CHECK_DATE - LAST_REPORT_PERIOD_START) >= (REPORT_INTERVAL*3600) )); then
        logTotal
        logLastPeriod
    fi

    if [ -z "$state" ]; then
        if [ -z "$PREV_CHECK_DATE" ]; then
            if is_number "$CONNECTIONS"; then
                logError "Jormungandr is started but not responding or something wrong with our script"
            else
                logWarn "Starting jormungandr because it looking stopped."
                stopJormungandr
                startJormungandr
            fi;
        elif isCriticalLag $CHECK_DATE $PREV_CHECK_DATE; then
            logWarn "Starting jormungandr because it not responding last $CRITICAL_LAG_IN_SEC seconds."
            stopJormungandr
            startJormungandr
        fi
    elif isBootstrappingState $state; then
        if ! isBootstrappingState $PREV_state; then
            if (( just_restarted )); then
                logInfo "Bootstrapping..."
            else
                logNotice "Bootstrapping..."
            fi
            (( TOTAL_BOOTSTRAP_COUNT++ ))
            (( LAST_REPORT_PERIOD_TOTAL_BOOTSTRAP_COUNT++ ))
        fi
        incrementBootstrapDuration
        incrementDowntime
    elif isRunningState $state; then
        incrementConnectionStatistic
        if isBootstrappingState $PREV_state; then
            incrementBootstrapDuration
            logNotice "Node bootstrapped in $LAST_BOOTSTRAP_DURATION seconds ($(displaytime $LAST_BOOTSTRAP_DURATION))"
        elif ! isRunningState $PREV_state; then
            logNotice "Node is running"
        else
            if isCriticalLag $uptime 0 && isCriticalLag ${lastReceivedBlockTime:-$CHECK_DATE} $lastBlockTime; then
                logWarn "Restarting node because of some blocks did not received during $CRITICAL_LAG_IN_SEC seconds"
                logInfo "Uptime before restart: $uptime seconds ($(displaytime $uptime))"
                incrementDowntime
                incrementUptimeDuration
                if restartJormungandr; then
                    (( JUST_RESTARTED = 1 ))
                fi
            elif isCriticalLag $CHECK_DATE ${lastReceivedBlockTime:-$CHECK_DATE} $UNBELIVABLE_TIME_WO_BLOCKS_IN_NET; then
                logWarn "Restarting node because no one block has been received during last $UNBELIVABLE_TIME_WO_BLOCKS_IN_NET seconds"
                logInfo "Uptime before restart: $uptime seconds ($(displaytime $uptime))"
                incrementDowntime
                incrementUptimeDuration
                if restartJormungandr; then
                    (( JUST_RESTARTED = 1 ))
                fi
            else
                incrementUptime
            fi
        fi
        (( LAST_BOOTSTRAP_DURATION = 0 ))
    else
        logError "Unknown node state: $state"
    fi

    if isRunningState $state || isBootstrappingState $state; then
        PREV_CHECK_DATE=$CHECK_DATE
    fi
    PREV_state=$state

    sleep "${CHECK_INTERVAL}s"
    (( CHECK_CYCLES_FROM_START += 1 ))
done
