#!/bin/bash

. $(dirname $0)/cardano-utils-common


function showHelp() {
    cat <<EOF
usage: $(basename $0) [-i INTERVAL] [-e ENCLAVE] [-d] [-C] [-S] [-E]
          [-a TELEGRAM_ACCESS_TOKEN] [-c CHANNEL_ID] [-n HEADER]
          [-L LOG_LEVEL] [-j] [-h]
  -i  Interval that will be used for regular checking.
      If not specified then send info only once and exit.
  -e  Enclave leader id. It is integer number. It is helpfull if node carries leadership of several pools.
      If specified then only slots of this enclave leader will be counted. If not specified then all slots
      will be counted regardles of which enclave it belongs to.
      This option can be specified several times for several different enclave leader ids to count.
  -d  Publish only in the case of changes. Do not publish state at the moment of start\.
  -C  Do not report count of slots for an epoch.
  -S  Do not include into the report the slots schedule.
  -E  Do not report block creation events.
  -a  Bot access token. If not specified then environment variable with name \`TELEGRAM_BOT_AUTH_TOKEN\`
      will be used for authentication. If none specified then telegram output will not be used.
  -c  Telegram channel to which send messages. E.g. \`@CardanoNodesHeartbeat\`. You can specify this option
      several times to send message to several channels.
  -n  Pool name/identifier. You can use the ticker of your pool here.
      If defined it will be the first line of every telegram message.
  -L  Log level. One of the values \`error\`, \`warn\`, \`info\`, \`debug\`, \`trace\`. Only messages with
      this and stronger severity level will be logged.
  -j  Prepare messages for journald severity levels.
  -h  Show this help.

This scrip collect and report information about the own slots of the pool to stdout and the telegram
channel via the Telegram Bot.

By default, it is assumed that all time INTERVALs are set in seconds. But you can explicitly specify time units:
\`s\` - seconds, \`m\` - minutes, \`h\` - hours, \`d\` - days, \`w\` - weeks. E.g. \`25s\`, \`15m\`, \`1h\`.
EOF
}


declare -a T_CHANNEL_IDS
T_CHANNEL_IDS=()
# Access token for Telegram Bot API
T_AUTH_TOKEN=$TELEGRAM_BOT_AUTH_TOKEN

while getopts 'e:n:i:a:c:L:CSEdjh' c
do
    case $c in
        e) if ! is_number "$OPTARG"; then
               logError 'Wrong value for option `-e`' >&2
               showHelp >&2
               exit 1
           fi
           ENCLAVE_LEADER_ID[${#ENCLAVE_LEADER_ID[*]}]="$OPTARG" ;;
        n) POOL_NAME="$OPTARG" ;;
        i) INTERVAL=$(printf "%s" $OPTARG | parseInterval)
           if [ -z $INTERVAL ] || (( INTERVAL < 0 )); then
               logError 'Wrong value for option `-r`' >&2
               showHelp >&2
               exit 1
           fi
           ;;
        a) T_AUTH_TOKEN="$OPTARG" ;;
        c) T_CHANNEL_IDS[${#T_CHANNEL_IDS[*]}]="$OPTARG" ;;
        L) if ! parseLogLevel $OPTARG; then
               logError 'Wrong value for option `-L`' >&2
               showHelp >&2
               exit 1
           fi
           ;;
        d) ONLY_CHANGES=1 ;;
        j) WITH_JOURNALD=1;;
        C) WO_SLOTS_COUNT=1;;
        S) WO_SCHEDULE_TIMES=1;;
        E) WO_BLOCK_CREATION_EVENTS=1;;
        h) showHelp; exit 0 ;;
        ?) showHelp >&2; exit 1;;
    esac
done


CURRENT_EPOCH=
CURRENT_EPOCH_BLOCK_COUNT=
LAST_REPORTED_EPOCH=
PREVIOUS_LEADERS_JSON=
declare -A POSTPONED_BLOCKS

function fetchNodeStats {
    local JSON ERR_MSG
    catch JSON ERR_MSG "curl -sSf $JORMUNGANDR_RESTAPI_URL/v0/node/stats"
    if [ -n "$ERR_MSG" ]; then
        logError "$ERR_MSG" >&2
        return 1
    fi
    echo -n "$JSON"
}

function getCurrentEpoch {
    # STDIN: node stats json

    jq -r '.lastBlockDate' | cut -d. -f1
}

function getLastBlockHeight {
    # STDIN: node stats json

    jq -r '.lastBlockHeight|tonumber'
}

function fetchLeadersLogs {
    local JSON ERR_MSG

    local ENCLAVE_JSON=true
    if (( ${#ENCLAVE_LEADER_ID[*]} > 0 )); then
        local ENCLAVE_JSON_=$(printf ' or (.enclave_leader_id==%d)' ${ENCLAVE_LEADER_ID[*]})
        ENCLAVE_JSON_=${ENCLAVE_JSON_:4}
        ENCLAVE_JSON=${ENCLAVE_JSON_:-true}
    fi

    local JSON ERR_MSG
    catch JSON ERR_MSG "curl -sSf $JORMUNGANDR_RESTAPI_URL/v0/leaders/logs"
    if [ -n "$ERR_MSG" ]; then
        logError "$ERR_MSG" >&2
        return 1
    fi
    if [ -n "$JSON" ]; then
        echo -n $JSON | \
            jq "[( .[] | select(${ENCLAVE_JSON}) )] | sort_by(.scheduled_at_time | strptime(\"%Y-%m-%dT%H:%M:%S%z\") | mktime)"
    fi
}

function getLeadersLogsForEpoch {
    # STDIN: leaders logs json

    local EPOCH=$1
    jq --arg EPOCH "$EPOCH" \
       '[ .[] | select(.scheduled_at_date|startswith($EPOCH+".")) ]'
}

function getCountOfSlots {
    # STDIN: leaders logs json

    jq -r "length"
}

function getScheduledTimes {
    # STDIN: leaders logs json

    jq -r ".[] | .scheduled_at_time | strptime(\"%Y-%m-%dT%H:%M:%S%z\") | mktime"
}

function getScheduledDates {
    # STDIN: leaders logs json

    jq -r ".[] | .scheduled_at_date"
}

function getNewBlocks {
    local oldJson="${1:-[]}"
    local newJson="${2:-[]}"
    # local oldJson="$(cat leaders.1.json)"
    # local newJson="$(cat leaders.2.json)"
    echo "{\"old\":${oldJson},\"new\":${newJson}}" | jq -rc '
.old as $old
| .new[]
| . as $it
| select(
       [
         $old[]
         | (
                 .scheduled_at_date == $it.scheduled_at_date
             and .enclave_leader_id == $it.enclave_leader_id
             and .status == $it.status
           ) | not
       ] | all
       and $it.status != "Pending"
  )
'
}

function printBlockSuccess {
    local SIMPLE_LOGGING=$1
    local blockJson=$2

    local BLOCK_ID=$(echo -n $blockJson | jq -rc '.status.Block.block')
    local SLOT=$(echo -n $blockJson | jq -rc '.scheduled_at_date')
    local HEIGHT=$(echo -n $blockJson | jq -rc '.status.Block.chain_length + 1')

    if [ "$SIMPLE_LOGGING" == "yes" ]; then
        logNotice "Slot <b><i>$SLOT</i></b> $(qs)SUCCEEDED$(qe): block <a href=\"https://shelleyexplorer.cardano.org/en/block/$BLOCK_ID\">$BLOCK_ID</a> was successfully produced at height <b><i>$HEIGHT</i></b>."
    else
        logNotice "Slot $SLOT SUCCEEDED: block $BLOCK_ID was successfully produced at height $HEIGHT."
    fi
}

function printBlockFailFork {
    local SIMPLE_LOGGING=$1
    local blockJson=$2

    local BLOCK_ID=$(echo -n $blockJson | jq -rc '.status.Block.block')
    local SLOT=$(echo -n $blockJson | jq -rc '.scheduled_at_date')
    local HEIGHT=$(echo -n $blockJson | jq -rc '.status.Block.chain_length + 1')

    if [ "$SIMPLE_LOGGING" == "yes" ]; then
        logNotice "Slot <b><i>$SLOT</i></b> $(qs)FAILED$(qe): block <a href=\"https://shelleyexplorer.cardano.org/en/block/$BLOCK_ID\">$BLOCK_ID</a> at height <b><i>$HEIGHT</i></b> got into a competitive fork that lost."
    else
        logNotice "Slot $SLOT FAILED: block $BLOCK_ID at height $HEIGHT got into a competitive fork that lost."
    fi
}

function printBlockFail {
    local SIMPLE_LOGGING=$1
    local blockJson=$2

    local SLOT=$(echo -n $blockJson | jq -rc '.scheduled_at_date')
    local REASON=$(echo -n $blockJson | jq -rc '..|.reason?|select(length > 0)')

    local DEFAULT_REASON="ufortunately the attempt to create a block failed"

    if [ "$SIMPLE_LOGGING" == "yes" ]; then
        logNotice "Slot <b><i>$SLOT</i></b> $(qs)FAILED$(qe): $(if [ -n "$REASON" ];then echo "$REASON"; else echo "$DEFAULT_REASON"; fi)."
    else
        logNotice "Slot $SLOT FAILED: $(if [ -n "$REASON" ];then echo "$REASON"; else echo "$DEFAULT_REASON"; fi)."
    fi
}

function makeOneCreatedBlockReport {
    local lastBlockHeight=$1
    local blockJson=$2

    local enough_confirmation_count=10
    local block=$(echo -n "$blockJson" | jq -rc '.status.Block?.block')
    if [ -n "$block" ] && [ "null" != "$block" ]; then
        local confirmation_count ERR_MSG
        catch confirmation_count ERR_MSG "curl -sSf $JORMUNGANDR_RESTAPI_URL/v0/block/$block/next_id?count=$enough_confirmation_count | xxd -p -c32 | wc -l"
        if [ -n "$ERR_MSG" ] && ! isNotFoundMessage "$ERR_MSG"; then
            logError "$ERR_MSG" >&2
        fi
        if (( confirmation_count >= enough_confirmation_count )); then
            printBlockSuccess "no"  "$blockJson"
            printBlockSuccess "yes" "$blockJson" | sendToTelegram
            return 0
        else
            local blockHeight=$(echo -n "$blockJson" | jq -rc '.status.Block?.chain_length + 1')
            if (( (confirmation_count + blockHeight) < (lastBlockHeight - enough_confirmation_count) )); then
                # this block in a fork
                printBlockFailFork "no" "$blockJson"
                printBlockFailFork "yes" "$blockJson" | sendToTelegram
                return 0
            else
                # Block was produced but now it is not clear will it be applied by the network. It will be checked later.
                return 1
            fi

        fi
    else
        local isPendingStatus=$(echo -n "$blockJson" | jq -rc '.status=="Pending"')
        if [ "$isPendingStatus" != "true" ]; then
            printBlockFail "no" "$blockJson"
            printBlockFail "yes" "$blockJson" | sendToTelegram
            return 0
        fi
    fi
}

function makeCreatedBlocksReports {

    if [ -z "$PREVIOUS_LEADERS_JSON" ] && [ -n "$ONLY_CHANGES" ]; then
        return
    fi

    local nodeStatsJson=$1
    local leadersLogsJson=$2

    local lastBlockHeight=$(echo -n $nodeStatsJson | getLastBlockHeight)
    for blockJson in "${!POSTPONED_BLOCKS[@]}"
    do
        makeOneCreatedBlockReport "$lastBlockHeight" "$blockJson" && unset 'POSTPONED_BLOCKS[$blockJson]' || POSTPONED_BLOCKS["$blockJson"]=1
    done

    readarray -t blocksJson < <(getNewBlocks "$PREVIOUS_LEADERS_JSON" "$leadersLogsJson")
    for blockJson in "${blocksJson[@]}"
    do
        makeOneCreatedBlockReport "$lastBlockHeight" "$blockJson" && unset 'POSTPONED_BLOCKS[$blockJson]' || POSTPONED_BLOCKS["$blockJson"]=1
    done
}


function conditional_ticker {
    if [ -n "$POOL_NAME" ]; then
        echo " for $POOL_NAME"
    fi
}

function qs {
    echo -n "<u><b><i>"
}
function qe {
    echo -n "</i></b></u>"
}
function qs_ {
    echo -n "<u><i>"
}
function qe_ {
    echo -n "</i></u>"
}

function printNewEpochReport {
    local SIMPLE_LOGGING=$1

    if [ "$SIMPLE_LOGGING" == "yes" ]; then
        if [ -n "$CURRENT_EPOCH" ] && is_number $CURRENT_EPOCH_BLOCK_COUNT; then
            if ([ -z "$ONLY_CHANGES" ] || [ -n "$LAST_REPORTED_EPOCH" ] ) && (( CURRENT_EPOCH != LAST_REPORTED_EPOCH )); then
                if [ -z "$WO_SLOTS_COUNT" ]; then
                    if (( CURRENT_EPOCH_BLOCK_COUNT == 1 )); then
                        logNotice "$(qs)${CURRENT_EPOCH_BLOCK_COUNT}$(qe) slot was allocated for the epoch $(qs)${CURRENT_EPOCH}$(qe)."
                    else
                        logNotice "$(qs)${CURRENT_EPOCH_BLOCK_COUNT}$(qe) slots were allocated for the epoch $(qs)${CURRENT_EPOCH}$(qe)."
                    fi
                fi
                if [ -z "$WO_SCHEDULE_TIMES" ] && (( ${#SCHEDULED_AT_TIME_ARR[*]} > 0 )); then
                    logNotice "Slots schedule:"
                    for idx in ${!SCHEDULED_AT_TIME_ARR[*]}
                    do
                        local time_item="${SCHEDULED_AT_TIME_ARR[$idx]}"
                        local slot_item="${SCHEDULED_AT_DATE_ARR[$idx]}"
                        logNotice "  <i>$(date '+%Y-%m-%d ' -u -d"@$time_item")<b><u>$(date '+%H:%M:%S' -u -d"@$time_item")</u></b> UTC</i> / $(qs)$slot_item$(qe)"
                    done
                fi
            fi
        fi
    else
        if [ -n "$CURRENT_EPOCH" ] && is_number $CURRENT_EPOCH_BLOCK_COUNT; then
            if ([ -z "$ONLY_CHANGES" ] || [ -n "$LAST_REPORTED_EPOCH" ] ) && (( CURRENT_EPOCH != LAST_REPORTED_EPOCH )); then
                if [ -z "$WO_SLOTS_COUNT" ]; then
                    if (( CURRENT_EPOCH_BLOCK_COUNT == 1 )); then
                        logNotice "${CURRENT_EPOCH_BLOCK_COUNT} slot was allocated for the epoch ${CURRENT_EPOCH}$(conditional_ticker)."
                    else
                        logNotice "${CURRENT_EPOCH_BLOCK_COUNT} slots were allocated for the epoch ${CURRENT_EPOCH}$(conditional_ticker)."
                    fi
                fi
                if [ -z "$WO_SCHEDULE_TIMES" ] && (( ${#SCHEDULED_AT_TIME_ARR[*]} > 0 )); then
                    logNotice "Slots schedule:"
                    for idx in ${!SCHEDULED_AT_TIME_ARR[*]}
                    do
                        local time_item="${SCHEDULED_AT_TIME_ARR[$idx]}"
                        local slot_item="${SCHEDULED_AT_DATE_ARR[$idx]}"
                        logNotice "  $(date '+%Y-%m-%d %H:%M:%S UTC' -u -d"@$time_item") / $slot_item"
                    done
                fi
            fi
        fi
    fi
}

function sendToTelegram {
    if [ -n "$T_AUTH_TOKEN" ] && (( ${#T_CHANNEL_IDS[*]} > 0 )); then
        local INPUT=$(cat)
        if [ -n "$INPUT" ]; then
            for channel in "${T_CHANNEL_IDS[@]}"
            do
                echo -e "${POOL_NAME:+${POOL_NAME}\n\n}${INPUT}" | postHtmlToTelegram "$T_AUTH_TOKEN" "$channel"
            done
        fi
    fi
}

function makeNewEpochReport {
    local epochLeadersLogsJson="$1"
    local count=$(echo -n $epochLeadersLogsJson | getCountOfSlots)
    if is_number $count; then
        CURRENT_EPOCH=$epoch
        CURRENT_EPOCH_BLOCK_COUNT=$count
        SCHEDULED_AT_TIME_ARR=( $(echo -n $epochLeadersLogsJson | getScheduledTimes) )
        SCHEDULED_AT_DATE_ARR=( $(echo -n $epochLeadersLogsJson | getScheduledDates) )
        printNewEpochReport "no"
        if [ -n "$T_AUTH_TOKEN" ] && (( ${#T_CHANNEL_IDS[*]} > 0 )); then
            printNewEpochReport "yes" | sendToTelegram
        fi
        LAST_REPORTED_EPOCH=$CURRENT_EPOCH
    else
        logError "Cannot get count of the slots for epoch \`${epoch}\`" >&2
    fi
}

function doOnce {
    local nodeStatsJson=$(fetchNodeStats)
    if [ -z "$nodeStatsJson" ]; then
        return 1
    fi
    local epoch=$(echo -n $nodeStatsJson | getCurrentEpoch)
    if is_number $epoch; then
        local leadersLogsJson=$(fetchLeadersLogs)
        local epochLeadersLogsJson=$(echo -n $leadersLogsJson | getLeadersLogsForEpoch $epoch)
        logTrace "$epochLeadersLogsJson" >&2

        makeNewEpochReport "$epochLeadersLogsJson"

        if [ -z "$WO_BLOCK_CREATION_EVENTS" ]; then
            makeCreatedBlocksReports "$nodeStatsJson" "$leadersLogsJson"
        fi

        PREVIOUS_LEADERS_JSON="$leadersLogsJson"
    else
        logError "Cannot get current epoch number" >&2
    fi
}


doOnce

while [ -n "$INTERVAL" ]
do
    sleep "${INTERVAL}s"
    doOnce
done

exit 0
